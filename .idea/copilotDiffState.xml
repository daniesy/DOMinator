<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Nodes/Node.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Nodes/Node.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace Daniesy\DOMinator\Nodes;&#10;&#10;use Daniesy\DOMinator\Traits\HandlesAttributes;&#10;use Daniesy\DOMinator\Traits\QueriesNodes;&#10;use Daniesy\DOMinator\Traits\ModifiesNode;&#10;use Daniesy\DOMinator\NodeList;&#10;use Daniesy\DOMinator\CssParser;&#10;&#10;// Represents a node in the HTML tree (element or text)&#10;/**&#10; * @property string $innerText&#10; */&#10;&#10;class Node&#10;{&#10;    use QueriesNodes, ModifiesNode, HandlesAttributes;&#10;&#10;    // Define constants for node types&#10;    public const string NODE_TYPE_TEXT = 'text';&#10;    public const string NODE_TYPE_COMMENT = 'comment';&#10;    public const string NODE_TYPE_CDATA = 'cdata';&#10;    public const string NODE_TYPE_ELEMENT = 'element';&#10;&#10;    // Tags considered inline/phrasing for whitespace sensitivity&#10;    private static array $inlineTags = [&#10;        'a',&#10;        'abbr',&#10;        'b',&#10;        'bdi',&#10;        'bdo',&#10;        'br',&#10;        'cite',&#10;        'code',&#10;        'data',&#10;        'dfn',&#10;        'em',&#10;        'i',&#10;        'img',&#10;        'input',&#10;        'kbd',&#10;        'label',&#10;        'mark',&#10;        'q',&#10;        'rp',&#10;        'rt',&#10;        'ruby',&#10;        's',&#10;        'samp',&#10;        'small',&#10;        'span',&#10;        'strong',&#10;        'sub',&#10;        'sup',&#10;        'time',&#10;        'u',&#10;        'var',&#10;        'wbr',&#10;        'select',&#10;        'textarea',&#10;        'button'&#10;    ];&#10;&#10;    public NodeList $children;&#10;    public ?Node $parent = null;&#10;    public string $doctype = '';&#10;    public string $xmlDeclaration = '';&#10;&#10;    public function __construct(&#10;        public string $tag = '',&#10;        public array $attributes = [],&#10;        public bool $isText = false,&#10;        protected string $contents = '',&#10;        public bool $isComment = false,&#10;        public bool $isCdata = false,&#10;        public string $namespace = ''&#10;    ) {&#10;        $this-&gt;children = new NodeList();&#10;    }&#10;&#10;    /**&#10;     * Magic getter for node properties&#10;     * &#10;     * @param string $name The property name&#10;     * @return mixed The property value or null&#10;     */&#10;    public function __get(string $name): mixed&#10;    {&#10;        return match ($name) {&#10;            'innerText' =&gt; $this-&gt;getInnerText(),&#10;            default =&gt; $this-&gt;$name ?? null&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Magic setter for node properties&#10;     * &#10;     * @param string $name The property name&#10;     * @param mixed $value The value to set&#10;     */&#10;    public function __set(string $name, mixed $value): void&#10;    {&#10;        if ($name === 'innerText') {&#10;            $this-&gt;setInnerText((string)$value);&#10;            return;&#10;        }&#10;        $this-&gt;$name = $value;&#10;    }&#10;&#10;    public function toHtml(bool $minify = true, int $level = 0): string&#10;    {&#10;        $indent = ($minify ? '' : str_repeat(&quot;    &quot;, $level));&#10;        $newline = $minify ? '' : &quot;\n&quot;;&#10;        // Special handling: if this is the artificial root node, only export its children&#10;        if ($this-&gt;tag === 'root') {&#10;            $html = '';&#10;            if (isset($this-&gt;xmlDeclaration) &amp;&amp; $this-&gt;xmlDeclaration) {&#10;                $html .= $this-&gt;xmlDeclaration . $newline;&#10;            }&#10;            if (isset($this-&gt;doctype) &amp;&amp; $this-&gt;doctype) {&#10;                $html .= $this-&gt;doctype . $newline;&#10;            }&#10;            // Decide if it's safe to pretty print children at the root level&#10;            $canPrettyRoot = !$minify &amp;&amp; $this-&gt;canSafelyPrettyPrintChildren();&#10;            foreach ($this-&gt;children as $child) {&#10;                // Skip whitespace-only text nodes only when it's safe to pretty print&#10;                if ($canPrettyRoot &amp;&amp; !$minify &amp;&amp; $child-&gt;isText &amp;&amp; trim($child-&gt;innerText) === '') {&#10;                    continue;&#10;                }&#10;                $html .= $child-&gt;toHtml($minify, $minify ? 0 : $level);&#10;                if ($canPrettyRoot &amp;&amp; !$minify) $html .= $newline;&#10;            }&#10;            return $minify ? $html : ($canPrettyRoot ? rtrim($html, &quot;\n&quot;) : $html);&#10;        }&#10;        // If this is the &lt;html&gt; node and has a doctype or xmlDeclaration, prepend them&#10;        $html = '';&#10;        if (isset($this-&gt;xmlDeclaration) &amp;&amp; $this-&gt;xmlDeclaration) {&#10;            $html .= $this-&gt;xmlDeclaration . $newline;&#10;        }&#10;        if ($this-&gt;tag === 'html' &amp;&amp; isset($this-&gt;doctype) &amp;&amp; $this-&gt;doctype) {&#10;            $html .= $this-&gt;doctype . $newline;&#10;        }&#10;        if ($this-&gt;isComment) {&#10;            return $indent . '&lt;!--' . $this-&gt;innerText . '--&gt;';&#10;        }&#10;        if ($this-&gt;isCdata) {&#10;            return $indent . '&lt;![CDATA[' . $this-&gt;innerText . ']]&gt;';&#10;        }&#10;        if ($this-&gt;isText) {&#10;            // For text nodes, don't add indentation in pretty print mode&#10;            // If it's only whitespace and we're in pretty print mode, skip it&#10;            $text = str_replace('&amp;#039;', '&amp;apos;', htmlspecialchars($this-&gt;innerText, ENT_QUOTES | ENT_HTML5));&#10;            if (!$minify &amp;&amp; trim($text) === '') {&#10;                return '';&#10;            }&#10;            return $text;&#10;        }&#10;        $attr = '';&#10;        foreach ($this-&gt;attributes as $k =&gt; $v) {&#10;            $attr .= ' ' . $k . '=&quot;' . str_replace('&amp;#039;', '&amp;apos;', htmlspecialchars($v, ENT_QUOTES | ENT_HTML5)) . '&quot;';&#10;        }&#10;        $html .= $indent . &quot;&lt;{$this-&gt;tag}{$attr}&gt;&quot;;&#10;        if ($this-&gt;children-&gt;length) {&#10;            // Special handling for elements with only text content&#10;            if ($this-&gt;children-&gt;length === 1 &amp;&amp; $this-&gt;children-&gt;item(0)?-&gt;isText) {&#10;                // For &quot;title&quot; tag in SVG, compress whitespace&#10;                if ($this-&gt;tag === 'title' &amp;&amp; $this-&gt;parent &amp;&amp; $this-&gt;parent-&gt;tag === 'svg') {&#10;                    $html .= trim(preg_replace('/\s+/', ' ', $this-&gt;children-&gt;item(0)-&gt;innerText));&#10;                } else {&#10;                    $html .= $this-&gt;children-&gt;item(0)-&gt;toHtml($minify, $level + 1);&#10;                }&#10;            } else {&#10;                // Only pretty print (add newlines/indentation) when it's safe and won't affect rendering&#10;                $canPretty = !$minify &amp;&amp; $this-&gt;canSafelyPrettyPrintChildren();&#10;                if ($canPretty) {&#10;                    $html .= $newline;&#10;                    foreach ($this-&gt;children as $child) {&#10;                        // Skip whitespace-only text nodes when pretty printing safely&#10;                        if ($child-&gt;isText &amp;&amp; trim($child-&gt;innerText) === '') {&#10;                            continue;&#10;                        }&#10;                        $html .= $child-&gt;toHtml($minify, $level + 1);&#10;                        $html .= $newline;&#10;                    }&#10;                    $html .= $indent;&#10;                } else {&#10;                    // Unsafe to pretty print: concatenate children without introducing newlines&#10;                    foreach ($this-&gt;children as $child) {&#10;                        // Do not drop whitespace-only text nodes here; they may be significant&#10;                        // Reset indentation to avoid inserting spaces without a preceding newline&#10;                        $html .= $child-&gt;toHtml($minify, 0);&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            $html .= str_replace('&amp;#039;', '&amp;apos;', htmlspecialchars($this-&gt;innerText, ENT_QUOTES | ENT_HTML5));&#10;        }&#10;        $html .= &quot;&lt;/{$this-&gt;tag}&gt;&quot;;&#10;        return $html;&#10;    }&#10;&#10;    // Determine if this element is inline/phrasing&#10;    private function isInlineElement(): bool&#10;    {&#10;        return in_array(strtolower($this-&gt;tag), self::$inlineTags, true);&#10;    }&#10;&#10;    // Determine if it's safe to pretty print (insert newlines/indentation) among children&#10;    // Safe when:&#10;    // - This element itself is not inline, and&#10;    // - There are no text children with non-whitespace content, and&#10;    // - All element children are not inline (i.e., block-like or unknown non-inline like SVG)&#10;    // - There are no comment/CDATA nodes mixed among inline/text content (to be conservative)&#10;    private function canSafelyPrettyPrintChildren(): bool&#10;    {&#10;        $hasSignificantText = false;&#10;        foreach ($this-&gt;children as $child) {&#10;            if ($child-&gt;isText) {&#10;                if (preg_match('/\S/u', $child-&gt;innerText)) {&#10;                    $hasSignificantText = true;&#10;                    break;&#10;                }&#10;                continue;&#10;            }&#10;            if ($child-&gt;tag &amp;&amp; in_array(strtolower($child-&gt;tag), self::$inlineTags, true)) {&#10;                // Inline child present -&gt; pretty printing could introduce visible spaces&#10;                return false;&#10;            }&#10;        }&#10;        if ($hasSignificantText) return false;&#10;        return true;&#10;    }&#10;&#10;    public function toInlinedHtml(bool $minify = true): string&#10;    {&#10;        $styleNodes = [];&#10;        $allCssRules = [];&#10;        // Collect all &lt;style&gt; nodes and parse their CSS&#10;        $this-&gt;collectStyleNodes($styleNodes);&#10;        foreach ($styleNodes as $styleNode) {&#10;            $css = '';&#10;            if (isset($styleNode-&gt;children)) {&#10;                foreach ($styleNode-&gt;children as $child) {&#10;                    if ($child) {&#10;                        $css .= $child-&gt;innerText;&#10;                    }&#10;                }&#10;            }&#10;            $parsed = CssParser::parse($css);&#10;            $allCssRules[] = ['node' =&gt; $styleNode, 'rules' =&gt; $parsed];&#10;        }&#10;        // Map: selector =&gt; [rule, props, raw, styleNode]&#10;        $selectorMap = [];&#10;        foreach ($allCssRules as $block) {&#10;            foreach ($block['rules'] as $rule) {&#10;                if ($rule['type'] === 'rule') {&#10;                    $selectorMap[] = [&#10;                        'selector' =&gt; $rule['selector'],&#10;                        'props' =&gt; $rule['props'],&#10;                        'raw' =&gt; $rule['raw'],&#10;                        'styleNode' =&gt; $block['node'],&#10;                    ];&#10;                }&#10;            }&#10;        }&#10;        // Inline styles and track which rules were inlined&#10;        $inlined = [];&#10;        $this-&gt;applyAdvancedInlineStyles($selectorMap, $inlined);&#10;        // Deep clone, removing only inlined rules from &lt;style&gt; tags&#10;        $cloned = $this-&gt;deepCloneWithAdvancedStyleRemoval($allCssRules, $inlined);&#10;        return $cloned-&gt;toHtml($minify);&#10;    }&#10;&#10;    private function collectStyleNodes(array &amp;$styleNodes)&#10;    {&#10;        if ($this-&gt;tag === 'style') {&#10;            $styleNodes[] = $this;&#10;        }&#10;        if (isset($this-&gt;children)) {&#10;            foreach ($this-&gt;children as $child) {&#10;                if ($child) {&#10;                    $child-&gt;collectStyleNodes($styleNodes);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Applies all matching rules to this node and children, tracks inlined rules&#10;    private function applyAdvancedInlineStyles(array $selectorMap, array &amp;$inlined)&#10;    {&#10;        if ($this-&gt;tag &amp;&amp; !$this-&gt;isText &amp;&amp; !$this-&gt;isComment &amp;&amp; !$this-&gt;isCdata) {&#10;            $matchedProps = [];&#10;            foreach ($selectorMap as $entry) {&#10;                if (CssParser::matches($entry['selector'], $this)) {&#10;                    foreach ($entry['props'] as $k =&gt; $v) {&#10;                        $matchedProps[$k] = $v;&#10;                    }&#10;                    $nodeId = $entry['styleNode']-&gt;id ?? spl_object_id($entry['styleNode']);&#10;                    $inlined[$nodeId][$entry['raw']] = true;&#10;                }&#10;            }&#10;            if ($matchedProps) {&#10;                $styleValue = '';&#10;                foreach ($matchedProps as $k =&gt; $v) {&#10;                    $styleValue .= $k . ': ' . $v . ';';&#10;                }&#10;                $this-&gt;attributes['style'] = $styleValue;&#10;            }&#10;        }&#10;&#10;        if (isset($this-&gt;children)) {&#10;            foreach ($this-&gt;children as $child) {&#10;                if ($child) {&#10;                    $child-&gt;applyAdvancedInlineStyles($selectorMap, $inlined);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Deep clone, but for &lt;style&gt; nodes, remove only rules that were actually inlined&#10;    private function deepCloneWithAdvancedStyleRemoval(array $allCssRules, array $inlined): self|null&#10;    {&#10;        if ($this-&gt;tag === 'style') {&#10;            $css = '';&#10;            if (isset($this-&gt;children)) {&#10;                foreach ($this-&gt;children as $child) {&#10;                    if ($child) {&#10;                        $css .= $child-&gt;innerText;&#10;                    }&#10;                }&#10;            }&#10;            $parsed = CssParser::parse($css);&#10;            $kept = [];&#10;            foreach ($parsed as $rule) {&#10;                if ($rule['type'] === 'at') {&#10;                    $kept[] = $rule['raw'];&#10;                } elseif ($rule['type'] === 'rule') {&#10;                    $sid = $this-&gt;id ?? spl_object_id($this);&#10;                    if (!isset($inlined[$sid][$rule['raw']])) {&#10;                        $kept[] = $rule['raw'];&#10;                    }&#10;                }&#10;            }&#10;            $newCss = implode(' ', $kept);&#10;            if ($newCss === '') {&#10;                return null;&#10;            }&#10;            $clone = new self('style', $this-&gt;attributes);&#10;            if ($newCss !== '') {&#10;                $clone-&gt;appendChild(new self('', [], true, $newCss));&#10;            }&#10;            return $clone;&#10;        }&#10;        $clone = new self(&#10;            $this-&gt;tag,&#10;            $this-&gt;attributes,&#10;            $this-&gt;isText,&#10;            $this-&gt;isText ? $this-&gt;innerText : '',&#10;            $this-&gt;isComment,&#10;            $this-&gt;isCdata,&#10;            $this-&gt;namespace&#10;        );&#10;        $clone-&gt;doctype = $this-&gt;doctype ?? '';&#10;        $clone-&gt;xmlDeclaration = $this-&gt;xmlDeclaration ?? '';&#10;&#10;        if (isset($this-&gt;children)) {&#10;            foreach ($this-&gt;children as $child) {&#10;                if ($child) {&#10;                    $clonedChild = $child-&gt;deepCloneWithAdvancedStyleRemoval($allCssRules, $inlined);&#10;                    if ($clonedChild !== null) {&#10;                        $clone-&gt;appendChild($clonedChild);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return $clone;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace Daniesy\DOMinator\Nodes;&#10;&#10;use Daniesy\DOMinator\Traits\HandlesAttributes;&#10;use Daniesy\DOMinator\Traits\QueriesNodes;&#10;use Daniesy\DOMinator\Traits\ModifiesNode;&#10;use Daniesy\DOMinator\NodeList;&#10;use Daniesy\DOMinator\CssParser;&#10;&#10;// Represents a node in the HTML tree (element or text)&#10;/**&#10; * @property string $innerText&#10; */&#10;&#10;class Node&#10;{&#10;    use QueriesNodes, ModifiesNode, HandlesAttributes;&#10;&#10;    // Define constants for node types&#10;    public const string NODE_TYPE_TEXT = 'text';&#10;    public const string NODE_TYPE_COMMENT = 'comment';&#10;    public const string NODE_TYPE_CDATA = 'cdata';&#10;    public const string NODE_TYPE_ELEMENT = 'element';&#10;&#10;    // Tags considered inline/phrasing for whitespace sensitivity&#10;    private static array $inlineTags = [&#10;        'a',&#10;        'abbr',&#10;        'b',&#10;        'bdi',&#10;        'bdo',&#10;        'br',&#10;        'cite',&#10;        'code',&#10;        'data',&#10;        'dfn',&#10;        'em',&#10;        'i',&#10;        'img',&#10;        'input',&#10;        'kbd',&#10;        'label',&#10;        'mark',&#10;        'q',&#10;        'rp',&#10;        'rt',&#10;        'ruby',&#10;        's',&#10;        'samp',&#10;        'small',&#10;        'span',&#10;        'strong',&#10;        'sub',&#10;        'sup',&#10;        'time',&#10;        'u',&#10;        'var',&#10;        'wbr',&#10;        'select',&#10;        'textarea',&#10;        'button'&#10;    ];&#10;&#10;    // HTML void elements (never have closing tags)&#10;    private static array $voidElements = [&#10;        'area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr'&#10;    ];&#10;&#10;    public NodeList $children;&#10;    public ?Node $parent = null;&#10;    public string $doctype = '';&#10;    public string $xmlDeclaration = '';&#10;&#10;    public function __construct(&#10;        public string $tag = '',&#10;        public array $attributes = [],&#10;        public bool $isText = false,&#10;        protected string $contents = '',&#10;        public bool $isComment = false,&#10;        public bool $isCdata = false,&#10;        public string $namespace = ''&#10;    ) {&#10;        $this-&gt;children = new NodeList();&#10;    }&#10;&#10;    /**&#10;     * Magic getter for node properties&#10;     * &#10;     * @param string $name The property name&#10;     * @return mixed The property value or null&#10;     */&#10;    public function __get(string $name): mixed&#10;    {&#10;        return match ($name) {&#10;            'innerText' =&gt; $this-&gt;getInnerText(),&#10;            default =&gt; $this-&gt;$name ?? null&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Magic setter for node properties&#10;     * &#10;     * @param string $name The property name&#10;     * @param mixed $value The value to set&#10;     */&#10;    public function __set(string $name, mixed $value): void&#10;    {&#10;        if ($name === 'innerText') {&#10;            $this-&gt;setInnerText((string)$value);&#10;            return;&#10;        }&#10;        $this-&gt;$name = $value;&#10;    }&#10;&#10;    public function toHtml(bool $minify = true, int $level = 0): string&#10;    {&#10;        $indent = ($minify ? '' : str_repeat(&quot;    &quot;, $level));&#10;        $newline = $minify ? '' : &quot;\n&quot;;&#10;        // Special handling: if this is the artificial root node, only export its children&#10;        if ($this-&gt;tag === 'root') {&#10;            $html = '';&#10;            if (isset($this-&gt;xmlDeclaration) &amp;&amp; $this-&gt;xmlDeclaration) {&#10;                $html .= $this-&gt;xmlDeclaration . $newline;&#10;            }&#10;            if (isset($this-&gt;doctype) &amp;&amp; $this-&gt;doctype) {&#10;                $html .= $this-&gt;doctype . $newline;&#10;            }&#10;            // Decide if it's safe to pretty print children at the root level&#10;            $canPrettyRoot = !$minify &amp;&amp; $this-&gt;canSafelyPrettyPrintChildren();&#10;            foreach ($this-&gt;children as $child) {&#10;                // Skip whitespace-only text nodes only when it's safe to pretty print&#10;                if ($canPrettyRoot &amp;&amp; !$minify &amp;&amp; $child-&gt;isText &amp;&amp; trim($child-&gt;innerText) === '') {&#10;                    continue;&#10;                }&#10;                $html .= $child-&gt;toHtml($minify, $minify ? 0 : $level);&#10;                if ($canPrettyRoot &amp;&amp; !$minify) $html .= $newline;&#10;            }&#10;            return $minify ? $html : ($canPrettyRoot ? rtrim($html, &quot;\n&quot;) : $html);&#10;        }&#10;        // If this is the &lt;html&gt; node and has a doctype or xmlDeclaration, prepend them&#10;        $html = '';&#10;        if (isset($this-&gt;xmlDeclaration) &amp;&amp; $this-&gt;xmlDeclaration) {&#10;            $html .= $this-&gt;xmlDeclaration . $newline;&#10;        }&#10;        if ($this-&gt;tag === 'html' &amp;&amp; isset($this-&gt;doctype) &amp;&amp; $this-&gt;doctype) {&#10;            $html .= $this-&gt;doctype . $newline;&#10;        }&#10;        if ($this-&gt;isComment) {&#10;            return $indent . '&lt;!--' . $this-&gt;innerText . '--&gt;';&#10;        }&#10;        if ($this-&gt;isCdata) {&#10;            return $indent . '&lt;![CDATA[' . $this-&gt;innerText . ']]&gt;';&#10;        }&#10;        if ($this-&gt;isText) {&#10;            // For text nodes, don't add indentation in pretty print mode&#10;            // If it's only whitespace and we're in pretty print mode, skip it&#10;            $text = str_replace('&amp;#039;', '&amp;apos;', htmlspecialchars($this-&gt;innerText, ENT_QUOTES | ENT_HTML5));&#10;            if (!$minify &amp;&amp; trim($text) === '') {&#10;                return '';&#10;            }&#10;            return $text;&#10;        }&#10;        $attr = '';&#10;        foreach ($this-&gt;attributes as $k =&gt; $v) {&#10;            $attr .= ' ' . $k . '=&quot;' . str_replace('&amp;#039;', '&amp;apos;', htmlspecialchars($v, ENT_QUOTES | ENT_HTML5)) . '&quot;';&#10;        }&#10;        // Emit void element without closing tag&#10;        if ($this-&gt;tag &amp;&amp; in_array($this-&gt;tag, self::$voidElements, true)) {&#10;            return $indent . &quot;&lt;{$this-&gt;tag}{$attr}&gt;&quot;; // no children or closing tag&#10;        }&#10;        $html .= $indent . &quot;&lt;{$this-&gt;tag}{$attr}&gt;&quot;;&#10;        if ($this-&gt;children-&gt;length) {&#10;            // Special handling for elements with only text content&#10;            if ($this-&gt;children-&gt;length === 1 &amp;&amp; $this-&gt;children-&gt;item(0)?-&gt;isText) {&#10;                // For &quot;title&quot; tag in SVG, compress whitespace&#10;                if ($this-&gt;tag === 'title' &amp;&amp; $this-&gt;parent &amp;&amp; $this-&gt;parent-&gt;tag === 'svg') {&#10;                    $html .= trim(preg_replace('/\s+/', ' ', $this-&gt;children-&gt;item(0)-&gt;innerText));&#10;                } else {&#10;                    $html .= $this-&gt;children-&gt;item(0)-&gt;toHtml($minify, $level + 1);&#10;                }&#10;            } else {&#10;                // Only pretty print (add newlines/indentation) when it's safe and won't affect rendering&#10;                $canPretty = !$minify &amp;&amp; $this-&gt;canSafelyPrettyPrintChildren();&#10;                if ($canPretty) {&#10;                    $html .= $newline;&#10;                    foreach ($this-&gt;children as $child) {&#10;                        // Skip whitespace-only text nodes when pretty printing safely&#10;                        if ($child-&gt;isText &amp;&amp; trim($child-&gt;innerText) === '') {&#10;                            continue;&#10;                        }&#10;                        $html .= $child-&gt;toHtml($minify, $level + 1);&#10;                        $html .= $newline;&#10;                    }&#10;                    $html .= $indent;&#10;                } else {&#10;                    // Unsafe to pretty print: concatenate children without introducing newlines&#10;                    foreach ($this-&gt;children as $child) {&#10;                        // Do not drop whitespace-only text nodes here; they may be significant&#10;                        // Reset indentation to avoid inserting spaces without a preceding newline&#10;                        $html .= $child-&gt;toHtml($minify, 0);&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            $html .= str_replace('&amp;#039;', '&amp;apos;', htmlspecialchars($this-&gt;innerText, ENT_QUOTES | ENT_HTML5));&#10;        }&#10;        $html .= &quot;&lt;/{$this-&gt;tag}&gt;&quot;;&#10;        return $html;&#10;    }&#10;&#10;    // Determine if this element is inline/phrasing&#10;    private function isInlineElement(): bool&#10;    {&#10;        return in_array(strtolower($this-&gt;tag), self::$inlineTags, true);&#10;    }&#10;&#10;    // Determine if it's safe to pretty print (insert newlines/indentation) among children&#10;    // Safe when:&#10;    // - This element itself is not inline, and&#10;    // - There are no text children with non-whitespace content, and&#10;    // - All element children are not inline (i.e., block-like or unknown non-inline like SVG)&#10;    // - There are no comment/CDATA nodes mixed among inline/text content (to be conservative)&#10;    private function canSafelyPrettyPrintChildren(): bool&#10;    {&#10;        $hasSignificantText = false;&#10;        foreach ($this-&gt;children as $child) {&#10;            if ($child-&gt;isText) {&#10;                if (preg_match('/\S/u', $child-&gt;innerText)) {&#10;                    $hasSignificantText = true;&#10;                    break;&#10;                }&#10;                continue;&#10;            }&#10;            if ($child-&gt;tag &amp;&amp; in_array(strtolower($child-&gt;tag), self::$inlineTags, true)) {&#10;                // Inline child present -&gt; pretty printing could introduce visible spaces&#10;                return false;&#10;            }&#10;        }&#10;        if ($hasSignificantText) return false;&#10;        return true;&#10;    }&#10;&#10;    public function toInlinedHtml(bool $minify = true): string&#10;    {&#10;        $styleNodes = [];&#10;        $allCssRules = [];&#10;        // Collect all &lt;style&gt; nodes and parse their CSS&#10;        $this-&gt;collectStyleNodes($styleNodes);&#10;        foreach ($styleNodes as $styleNode) {&#10;            $css = '';&#10;            if (isset($styleNode-&gt;children)) {&#10;                foreach ($styleNode-&gt;children as $child) {&#10;                    if ($child) {&#10;                        $css .= $child-&gt;innerText;&#10;                    }&#10;                }&#10;            }&#10;            $parsed = CssParser::parse($css);&#10;            $allCssRules[] = ['node' =&gt; $styleNode, 'rules' =&gt; $parsed];&#10;        }&#10;        // Map: selector =&gt; [rule, props, raw, styleNode]&#10;        $selectorMap = [];&#10;        foreach ($allCssRules as $block) {&#10;            foreach ($block['rules'] as $rule) {&#10;                if ($rule['type'] === 'rule') {&#10;                    $selectorMap[] = [&#10;                        'selector' =&gt; $rule['selector'],&#10;                        'props' =&gt; $rule['props'],&#10;                        'raw' =&gt; $rule['raw'],&#10;                        'styleNode' =&gt; $block['node'],&#10;                    ];&#10;                }&#10;            }&#10;        }&#10;        // Inline styles and track which rules were inlined&#10;        $inlined = [];&#10;        $this-&gt;applyAdvancedInlineStyles($selectorMap, $inlined);&#10;        // Deep clone, removing only inlined rules from &lt;style&gt; tags&#10;        $cloned = $this-&gt;deepCloneWithAdvancedStyleRemoval($allCssRules, $inlined);&#10;        return $cloned-&gt;toHtml($minify);&#10;    }&#10;&#10;    private function collectStyleNodes(array &amp;$styleNodes)&#10;    {&#10;        if ($this-&gt;tag === 'style') {&#10;            $styleNodes[] = $this;&#10;        }&#10;        if (isset($this-&gt;children)) {&#10;            foreach ($this-&gt;children as $child) {&#10;                if ($child) {&#10;                    $child-&gt;collectStyleNodes($styleNodes);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Applies all matching rules to this node and children, tracks inlined rules&#10;    private function applyAdvancedInlineStyles(array $selectorMap, array &amp;$inlined)&#10;    {&#10;        if ($this-&gt;tag &amp;&amp; !$this-&gt;isText &amp;&amp; !$this-&gt;isComment &amp;&amp; !$this-&gt;isCdata) {&#10;            $matchedProps = [];&#10;            foreach ($selectorMap as $entry) {&#10;                if (CssParser::matches($entry['selector'], $this)) {&#10;                    foreach ($entry['props'] as $k =&gt; $v) {&#10;                        $matchedProps[$k] = $v;&#10;                    }&#10;                    $nodeId = $entry['styleNode']-&gt;id ?? spl_object_id($entry['styleNode']);&#10;                    $inlined[$nodeId][$entry['raw']] = true;&#10;                }&#10;            }&#10;            if ($matchedProps) {&#10;                $styleValue = '';&#10;                foreach ($matchedProps as $k =&gt; $v) {&#10;                    $styleValue .= $k . ': ' . $v . ';';&#10;                }&#10;                $this-&gt;attributes['style'] = $styleValue;&#10;            }&#10;        }&#10;&#10;        if (isset($this-&gt;children)) {&#10;            foreach ($this-&gt;children as $child) {&#10;                if ($child) {&#10;                    $child-&gt;applyAdvancedInlineStyles($selectorMap, $inlined);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Deep clone, but for &lt;style&gt; nodes, remove only rules that were actually inlined&#10;    private function deepCloneWithAdvancedStyleRemoval(array $allCssRules, array $inlined): self|null&#10;    {&#10;        if ($this-&gt;tag === 'style') {&#10;            $css = '';&#10;            if (isset($this-&gt;children)) {&#10;                foreach ($this-&gt;children as $child) {&#10;                    if ($child) {&#10;                        $css .= $child-&gt;innerText;&#10;                    }&#10;                }&#10;            }&#10;            $parsed = CssParser::parse($css);&#10;            $kept = [];&#10;            foreach ($parsed as $rule) {&#10;                if ($rule['type'] === 'at') {&#10;                    $kept[] = $rule['raw'];&#10;                } elseif ($rule['type'] === 'rule') {&#10;                    $sid = $this-&gt;id ?? spl_object_id($this);&#10;                    if (!isset($inlined[$sid][$rule['raw']])) {&#10;                        $kept[] = $rule['raw'];&#10;                    }&#10;                }&#10;            }&#10;            $newCss = implode(' ', $kept);&#10;            if ($newCss === '') {&#10;                return null;&#10;            }&#10;            $clone = new self('style', $this-&gt;attributes);&#10;            if ($newCss !== '') {&#10;                $clone-&gt;appendChild(new self('', [], true, $newCss));&#10;            }&#10;            return $clone;&#10;        }&#10;        $clone = new self(&#10;            $this-&gt;tag,&#10;            $this-&gt;attributes,&#10;            $this-&gt;isText,&#10;            $this-&gt;isText ? $this-&gt;innerText : '',&#10;            $this-&gt;isComment,&#10;            $this-&gt;isCdata,&#10;            $this-&gt;namespace&#10;        );&#10;        $clone-&gt;doctype = $this-&gt;doctype ?? '';&#10;        $clone-&gt;xmlDeclaration = $this-&gt;xmlDeclaration ?? '';&#10;&#10;        if (isset($this-&gt;children)) {&#10;            foreach ($this-&gt;children as $child) {&#10;                if ($child) {&#10;                    $clonedChild = $child-&gt;deepCloneWithAdvancedStyleRemoval($allCssRules, $inlined);&#10;                    if ($clonedChild !== null) {&#10;                        $clone-&gt;appendChild($clonedChild);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return $clone;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>